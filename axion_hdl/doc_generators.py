"""
Documentation Generator Module for Axion HDL

This module generates register documentation in various formats.
Uses axion_hdl for code formatting utilities.
"""

import os
import sys
from typing import Dict, List

# Import from axion_hdl (unified package)
from axion_hdl.code_formatter import CodeFormatter


class DocGenerator:
    """Generator for creating register documentation."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        self.formatter = CodeFormatter()
        
    def generate_markdown(self, modules: List[Dict]) -> str:
        """Generate Markdown documentation."""
        output_path = os.path.join(self.output_dir, "register_map.md")
        
        lines = [
            "# AXI Register Map Documentation",
            "",
            "Generated by Axion HDL",
            "",
            "---",
            ""
        ]
        
        for module in modules:
            lines.extend(self._generate_module_section(module))
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
            
        return output_path
    
    def _generate_module_section(self, module: Dict) -> List[str]:
        """Generate documentation section for one module."""
        base_addr = module.get('base_address', 0x00)
        base_addr_str = f"0x{base_addr:04X}" if base_addr != 0 else "0x0000"
        
        lines = [
            f"## Module: {module['name']}",
            "",
            f"**Source File:** `{os.path.basename(module['file'])}`  ",
            f"**Base Address:** {base_addr_str}  ",
            f"**CDC:** {'Enabled' if module['cdc_enabled'] else 'Disabled'}",
        ]
        
        if module['cdc_enabled']:
            lines.append(f"**CDC Stages:** {module['cdc_stages']}")
        
        lines.extend([
            "",
            "### Register Map",
            "",
            "| Address | Offset | Register Name | Type | Width | Access | R_STROBE | W_STROBE | Description |",
            "|---------|--------|---------------|------|-------|--------|----------|----------|-------------|"
        ])
        
        for reg in module['registers']:
            r_strobe = "✓" if reg['read_strobe'] else "-"
            w_strobe = "✓" if reg['write_strobe'] else "-"
            offset = reg.get('relative_address', reg['address'])
            description = reg.get('description', '-')
            lines.append(
                f"| {reg['address']} | {offset} | `{reg['signal_name']}` | {reg['signal_type']} | 32 | "
                f"{reg['access_mode']} | {r_strobe} | {w_strobe} | {description} |"
            )
        
        lines.extend([
            "",
            "### Port Descriptions",
            ""
        ])
        
        for reg in module['registers']:
            lines.append(f"#### {reg['signal_name']}")
            description = reg.get('description', '')
            if description:
                lines.append(f"*{description}*")
                lines.append("")
            lines.append(f"- **Address:** {reg['address']}")
            offset = reg.get('relative_address', reg['address'])
            lines.append(f"- **Offset:** {offset}")
            lines.append(f"- **Access Mode:** {reg['access_mode']}")
            lines.append(f"- **Type:** `std_logic_vector(31 downto 0)`")
            lines.append("")
            lines.append("**Ports:**")
            lines.append(f"- `{reg['signal_name']}` (inout): Register data signal")
            
            if reg['read_strobe']:
                lines.append(f"- `{reg['signal_name']}_rd_strobe` (out): Read strobe pulse")
            if reg['write_strobe']:
                lines.append(f"- `{reg['signal_name']}_wr_strobe` (out): Write strobe pulse")
            if reg['access_mode'] in ['RO', 'RW']:
                lines.append(f"- `{reg['signal_name']}_wr_en` (in): Write enable from VHDL logic")
            
            lines.append("")
        
        lines.extend([
            "---",
            ""
        ])
        
        return lines


class CHeaderGenerator:
    """Generator for creating C header files."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        
    def generate_header(self, module: Dict) -> str:
        """Generate C header file for a module."""
        module_name = module['name']
        output_filename = f"{module_name}_regs.h"
        output_path = os.path.join(self.output_dir, output_filename)
        
        lines = self._generate_header_content(module)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
            
        return output_path
    
    def _get_signal_width(self, signal_type: str) -> int:
        """Extract signal width from type string like '[31:0]' or '[47:0]'."""
        import re
        match = re.match(r'\[(\d+):(\d+)\]', signal_type)
        if match:
            high = int(match.group(1))
            low = int(match.group(2))
            return high - low + 1
        return 32  # Default to 32-bit
    
    def _get_num_regs(self, signal_width: int) -> int:
        """Calculate number of 32-bit registers needed for a signal."""
        return (signal_width + 31) // 32
    
    def _generate_header_content(self, module: Dict) -> List[str]:
        """Generate C header content with module-prefixed register names."""
        module_name = module['name'].upper()
        module_prefix = f"{module_name}_"
        base_addr = module.get('base_address', 0x00)
        
        lines = [
            "/**",
            f" * @file {module['name']}_regs.h",
            f" * @brief Register definitions for {module['name']} module",
            " * @note Generated by Axion HDL - Do not edit manually",
            " *",
            " * All register definitions use module prefix to avoid namespace collisions",
            f" * when multiple modules are included in the same project.",
            " */",
            "",
            f"#ifndef {module_name}_REGS_H",
            f"#define {module_name}_REGS_H",
            "",
            "#include <stdint.h>",
            "",
            f"/* Module Base Address */",
            f"#define {module_name}_BASE_ADDR    0x{base_addr:08X}",
            "",
            "/* Register Address Offsets (relative to base) */",
        ]
        
        # Register offsets (relative) - with module prefix
        # For wide signals (>32 bits), generate _REG0, _REG1, etc. offsets
        for reg in module['registers']:
            reg_name_upper = reg['signal_name'].upper()
            offset_int = reg.get('relative_address_int', reg['address_int'])
            signal_width = self._get_signal_width(reg['signal_type'])
            num_regs = self._get_num_regs(signal_width)
            description = reg.get('description', '')
            
            if num_regs == 1:
                # Single 32-bit register
                offset = reg.get('relative_address', reg['address'])
                if description:
                    lines.append(f"#define {module_prefix}{reg_name_upper}_OFFSET    {offset}  /* {description} */")
                else:
                    lines.append(f"#define {module_prefix}{reg_name_upper}_OFFSET    {offset}")
            else:
                # Multi-register signal
                desc_suffix = f" - {description}" if description else ""
                lines.append(f"/* {reg['signal_name']} is {signal_width} bits wide, occupies {num_regs} registers{desc_suffix} */")
                for i in range(num_regs):
                    reg_offset = offset_int + (i * 4)
                    lines.append(f"#define {module_prefix}{reg_name_upper}_REG{i}_OFFSET    0x{reg_offset:02X}")
        
        lines.extend([
            "",
            "/* Absolute Register Addresses */",
        ])
        
        # Absolute addresses - with module prefix
        for reg in module['registers']:
            reg_name_upper = reg['signal_name'].upper()
            addr_int = reg['address_int']
            signal_width = self._get_signal_width(reg['signal_type'])
            num_regs = self._get_num_regs(signal_width)
            
            if num_regs == 1:
                lines.append(f"#define {module_prefix}{reg_name_upper}_ADDR    {reg['address']}")
            else:
                for i in range(num_regs):
                    reg_addr = addr_int + (i * 4)
                    lines.append(f"#define {module_prefix}{reg_name_upper}_REG{i}_ADDR    0x{reg_addr:X}")
        
        lines.extend([
            "",
            "/* Signal Width Definitions (for multi-register signals) */",
        ])
        
        # Add width definitions for wide signals
        has_wide_signals = False
        for reg in module['registers']:
            signal_width = self._get_signal_width(reg['signal_type'])
            if signal_width > 32:
                has_wide_signals = True
                reg_name_upper = reg['signal_name'].upper()
                num_regs = self._get_num_regs(signal_width)
                lines.append(f"#define {module_prefix}{reg_name_upper}_WIDTH    {signal_width}")
                lines.append(f"#define {module_prefix}{reg_name_upper}_NUM_REGS    {num_regs}")
        
        if not has_wide_signals:
            lines.append("/* No signals wider than 32 bits */")
        
        lines.extend([
            "",
            "/* Register Access Macros (using module base address) */",
        ])
        
        # Read macros - with module prefix
        for reg in module['registers']:
            if reg['access_mode'] in ['RO', 'RW']:
                reg_name_upper = reg['signal_name'].upper()
                signal_width = self._get_signal_width(reg['signal_type'])
                num_regs = self._get_num_regs(signal_width)
                
                if num_regs == 1:
                    lines.append(
                        f"#define {module_prefix}READ_{reg_name_upper}()    "
                        f"(*((volatile uint32_t*)({module_name}_BASE_ADDR + {module_prefix}{reg_name_upper}_OFFSET)))"
                    )
                else:
                    # Multi-register read macros
                    for i in range(num_regs):
                        lines.append(
                            f"#define {module_prefix}READ_{reg_name_upper}_REG{i}()    "
                            f"(*((volatile uint32_t*)({module_name}_BASE_ADDR + {module_prefix}{reg_name_upper}_REG{i}_OFFSET)))"
                        )
        
        lines.append("")
        
        # Write macros - with module prefix
        for reg in module['registers']:
            if reg['access_mode'] in ['WO', 'RW']:
                reg_name_upper = reg['signal_name'].upper()
                signal_width = self._get_signal_width(reg['signal_type'])
                num_regs = self._get_num_regs(signal_width)
                
                if num_regs == 1:
                    lines.append(
                        f"#define {module_prefix}WRITE_{reg_name_upper}(val)    "
                        f"(*((volatile uint32_t*)({module_name}_BASE_ADDR + {module_prefix}{reg_name_upper}_OFFSET)) = (val))"
                    )
                else:
                    # Multi-register write macros
                    for i in range(num_regs):
                        lines.append(
                            f"#define {module_prefix}WRITE_{reg_name_upper}_REG{i}(val)    "
                            f"(*((volatile uint32_t*)({module_name}_BASE_ADDR + {module_prefix}{reg_name_upper}_REG{i}_OFFSET)) = (val))"
                        )
        
        lines.extend([
            "",
            "/* Register Structure */",
            f"typedef struct {{",
        ])
        
        for reg in module['registers']:
            offset = reg.get('relative_address', reg['address'])
            signal_width = self._get_signal_width(reg['signal_type'])
            num_regs = self._get_num_regs(signal_width)
            description = reg.get('description', '')
            desc_suffix = f" - {description}" if description else ""
            
            if num_regs == 1:
                lines.append(f"    volatile uint32_t {reg['signal_name']};  /* {offset} - {reg['access_mode']}{desc_suffix} */")
            else:
                # Multi-register fields
                for i in range(num_regs):
                    reg_offset_int = reg.get('relative_address_int', reg['address_int']) + (i * 4)
                    lines.append(f"    volatile uint32_t {reg['signal_name']}_reg{i};  /* 0x{reg_offset_int:02X} - {reg['access_mode']} ({signal_width}-bit signal, part {i}){desc_suffix} */")
        
        lines.extend([
            f"}} {module['name']}_regs_t;",
            "",
            "/* Access register block as structure */",
            f"#define {module_name}_REGS    ((volatile {module['name']}_regs_t*)({module_name}_BASE_ADDR))",
            "",
            f"#endif /* {module_name}_REGS_H */",
            ""
        ])
        
        return lines


class XMLGenerator:
    """Generator for creating XML register maps."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        
    def generate_xml(self, module: Dict) -> str:
        """Generate XML register map."""
        module_name = module['name']
        output_filename = f"{module_name}_regs.xml"
        output_path = os.path.join(self.output_dir, output_filename)
        
        lines = self._generate_xml_content(module)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
            
        return output_path
    
    def _generate_xml_content(self, module: Dict) -> List[str]:
        """Generate XML content."""
        base_addr = module.get('base_address', 0x00)
        
        lines = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<spirit:component xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5">',
            f'    <spirit:vendor>axion</spirit:vendor>',
            f'    <spirit:library>user</spirit:library>',
            f'    <spirit:name>{module["name"]}</spirit:name>',
            f'    <spirit:version>1.0</spirit:version>',
            '    <spirit:memoryMaps>',
            '        <spirit:memoryMap>',
            '            <spirit:name>register_map</spirit:name>',
            '            <spirit:addressBlock>',
            '                <spirit:name>registers</spirit:name>',
            f'                <spirit:baseAddress>0x{base_addr:X}</spirit:baseAddress>',
        ]
        
        # Calculate range (using relative addresses)
        if module['registers']:
            max_offset = max(
                reg.get('relative_address_int', reg['address_int']) 
                for reg in module['registers']
            )
            lines.append(f'                <spirit:range>{max_offset + 4}</spirit:range>')
        else:
            lines.append('                <spirit:range>0</spirit:range>')
            
        lines.append('                <spirit:width>32</spirit:width>')
        
        # Registers
        for reg in module['registers']:
            offset = reg.get('relative_address', reg['address'])
            description = reg.get('description', '')
            lines.extend([
                '                <spirit:register>',
                f'                    <spirit:name>{reg["signal_name"]}</spirit:name>',
            ])
            if description:
                lines.append(f'                    <spirit:description>{description}</spirit:description>')
            lines.extend([
                f'                    <spirit:addressOffset>{offset}</spirit:addressOffset>',
                '                    <spirit:size>32</spirit:size>',
                f'                    <spirit:access>{self._get_xml_access(reg["access_mode"])}</spirit:access>',
                '                    <spirit:field>',
                f'                        <spirit:name>{reg["signal_name"]}_data</spirit:name>',
                '                        <spirit:bitOffset>0</spirit:bitOffset>',
                '                        <spirit:bitWidth>32</spirit:bitWidth>',
                '                    </spirit:field>',
                '                </spirit:register>',
            ])
        
        lines.extend([
            '            </spirit:addressBlock>',
            '        </spirit:memoryMap>',
            '    </spirit:memoryMaps>',
            '</spirit:component>',
            ''
        ])
        
        return lines
    
    def _get_xml_access(self, access_mode: str) -> str:
        """Convert access mode to XML format."""
        mapping = {
            'RO': 'read-only',
            'WO': 'write-only',
            'RW': 'read-write'
        }
        return mapping.get(access_mode, 'read-write')
