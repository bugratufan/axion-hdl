"""
Documentation Generator Module for Axion HDL

This module generates register documentation in various formats.
Uses axion_hdl for code formatting utilities.
"""

import os
import sys
from typing import Dict, List

# Import from axion_hdl (unified package)
from axion_hdl.code_formatter import CodeFormatter


class DocGenerator:
    """Generator for creating register documentation."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        self.formatter = CodeFormatter()
        
    def generate_markdown(self, modules: List[Dict]) -> str:
        """Generate Markdown documentation."""
        output_path = os.path.join(self.output_dir, "register_map.md")
        
        lines = [
            "# AXI Register Map Documentation",
            "",
            "Generated by Axion HDL",
            "",
            "---",
            ""
        ]
        
        for module in modules:
            lines.extend(self._generate_module_section(module))
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
            
        return output_path
    
    def _generate_module_section(self, module: Dict) -> List[str]:
        """Generate documentation section for one module."""
        base_addr = module.get('base_address', 0x00)
        base_addr_str = f"0x{base_addr:04X}" if base_addr != 0 else "0x0000"
        
        lines = [
            f"## Module: {module['name']}",
            "",
            f"**Source File:** `{os.path.basename(module['file'])}`  ",
            f"**Base Address:** {base_addr_str}  ",
            f"**CDC:** {'Enabled' if module['cdc_enabled'] else 'Disabled'}",
        ]
        
        if module['cdc_enabled']:
            lines.append(f"**CDC Stages:** {module['cdc_stages']}")
        
        lines.extend([
            "",
            "### Register Map",
            "",
            "| Address | Offset | Register Name | Type | Width | Access | Default | Description |",
            "|---------|--------|---------------|------|-------|--------|---------|-------------|"
        ])
        
        # Group registers: standalone vs packed
        # For packed registers, we want to show the main 32-bit register first
        # We need to detect which registers are packed (is_packed=True)
        # But for the register map table, we should list the ADDR/OFFSET only once for the whole register.
        
        # Helper to group registers by address/name
        grouped_regs = {}
        processed_packed_names = set()
        
        for reg in module['registers']:
            if reg.get('is_packed'):
                # Group by actual register name (reg_name)
                packed_name = reg['reg_name']
                if packed_name not in grouped_regs:
                    grouped_regs[packed_name] = {
                        'type': 'packed',
                        'fields': [],
                        'info': reg # Keep one reg as info source for address/access
                    }
                grouped_regs[packed_name]['fields'].append(reg)
            else:
                grouped_regs[reg['signal_name']] = {
                    'type': 'standalone',
                    'info': reg
                }
                
        # To maintain order, iterate original list but skip already processed packed groups
        shown_groups = set()
        
        for reg in module['registers']:
            name_key = reg['reg_name'] if reg.get('is_packed') else reg['signal_name']
            
            if name_key in shown_groups:
                continue
            shown_groups.add(name_key)
            
            group = grouped_regs[name_key]
            info = group['info']
            
            offset = info.get('relative_address', info['address'])
            # Use grouped reg_name for packed, otherwise signal_name
            display_name = name_key 
            
            # Access: mixed for packed? Usually RW or RO. Take from first field.
            access = info['access_mode']
            
            # Default: For standalone, take 'default'. For packed, show 'Mixed' or combined hex if possible?
            # Let's show the combined default if available processing, or just Listing
            # Actually, generator logic combines defaults into the main register default.
            # But here we might not have that easily. Let's just default to '-' for packed row, and details in description.
            default_val = info.get('default_value', '-')
            if default_val != '-':
                 default_val = f"0x{int(default_val):X}"
            
            desc = info.get('description', '-')
            
            if group['type'] == 'packed':
                # Show main register row
                lines.append(
                    f"| {info['address']} | {offset} | `{display_name}` | [31:0] | 32 | "
                    f"{access} | {default_val} | **Packed Register** (see below) |"
                )
            else:
                lines.append(
                    f"| {info['address']} | {offset} | `{display_name}` | {info['signal_type']} | 32 | "
                    f"{access} | {default_val} | {desc} |"
                )
        
        lines.extend([
            "",
            "### Port Descriptions",
            ""
        ])
        
        # Reset shown groups for port section
        shown_groups = set()
        
        for reg in module['registers']:
            name_key = reg['reg_name'] if reg.get('is_packed') else reg['signal_name']
            if name_key in shown_groups:
                continue
            shown_groups.add(name_key)
            
            group = grouped_regs[name_key]
            info = group['info']
            
            lines.append(f"#### {name_key}")
            
            if group['type'] == 'packed':
                lines.append(f"**Packed Register** - Address: {info['address']} (Offset: {info.get('relative_address', info['address'])})")
                lines.append("")
                lines.append("| Field | Bits | Type | Access | Default | Description |")
                lines.append("|-------|------|------|--------|---------|-------------|")
                
                # Sort fields by bit offset (high to low usually preferred in docs, or low to high)
                # Let's do High to Low (MSB first)
                sorted_fields = sorted(group['fields'], key=lambda r: int(r.get('bit_offset', 0)), reverse=True)
                
                for field in sorted_fields:
                    fname = field['signal_name']
                    offset = int(field.get('bit_offset', 0))
                    width = int(field.get('width', 1))
                    bit_range = f"[{offset}]" if width == 1 else f"[{offset+width-1}:{offset}]"
                    fdefault = field.get('default_value', '-')
                    if fdefault != '-': fdefault = f"0x{int(fdefault):X}"
                    fdesc = field.get('description', '-')
                    
                    lines.append(f"| `{fname}` | {bit_range} | {field['signal_type']} | {field['access_mode']} | {fdefault} | {fdesc} |")
                lines.append("")
                
            else:
                # Standalone
                description = info.get('description', '')
                if description:
                    lines.append(f"*{description}*")
                    lines.append("")
                lines.append(f"- **Address:** {info['address']}")
                lines.append(f"- **Offset:** {info.get('relative_address', info['address'])}")
                lines.append(f"- **Access Mode:** {info['access_mode']}")
                defs = info.get('default_value', '-')
                if defs != '-': defs = f"0x{int(defs):X}"
                lines.append(f"- **Default:** {defs}")
                lines.append(f"- **Type:** `std_logic_vector(31 downto 0)`")
                lines.append("")
                lines.append("**Ports:**")
                lines.append(f"- `{info['signal_name']}` (inout): Register data signal")
                
                if info['read_strobe']:
                    lines.append(f"- `{info['signal_name']}_rd_strobe` (out): Read strobe pulse")
                if info['write_strobe']:
                    lines.append(f"- `{info['signal_name']}_wr_strobe` (out): Write strobe pulse")
                if info['access_mode'] in ['RO', 'RW']:
                    lines.append(f"- `{info['signal_name']}_wr_en` (in): Write enable from VHDL logic")
            
            lines.append("")
        
        lines.extend([
            "---",
            ""
        ])
        
        return lines


class CHeaderGenerator:
    """Generator for creating C header files."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        
    def generate_header(self, module: Dict) -> str:
        """Generate C header file for a module."""
        module_name = module['name']
        output_filename = f"{module_name}_regs.h"
        output_path = os.path.join(self.output_dir, output_filename)
        
        lines = self._generate_header_content(module)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
            
        return output_path
    
    def _get_signal_width(self, signal_type: str) -> int:
        """Extract signal width from type string like '[31:0]' or '[47:0]'."""
        import re
        match = re.match(r'\[(\d+):(\d+)\]', signal_type)
        if match:
            high = int(match.group(1))
            low = int(match.group(2))
            return high - low + 1
        return 32  # Default to 32-bit
    
    def _get_num_regs(self, signal_width: int) -> int:
        """Calculate number of 32-bit registers needed for a signal."""
        return (signal_width + 31) // 32
    
    def _generate_header_content(self, module: Dict) -> List[str]:
        """Generate C header content with module-prefixed register names."""
        module_name = module['name'].upper()
        module_prefix = f"{module_name}_"
        base_addr = module.get('base_address', 0x00)
        
        lines = [
            "/**",
            f" * @file {module['name']}_regs.h",
            f" * @brief Register definitions for {module['name']} module",
            " * @note Generated by Axion HDL - Do not edit manually",
            " *",
            " * All register definitions use module prefix to avoid namespace collisions",
            f" * when multiple modules are included in the same project.",
            " */",
            "",
            f"#ifndef {module_name}_REGS_H",
            f"#define {module_name}_REGS_H",
            "",
            "#include <stdint.h>",
            "",
            f"/* Module Base Address */",
            f"#define {module_name}_BASE_ADDR    0x{base_addr:08X}",
            "",
            "/* Register Address Offsets (relative to base) */",
        ]
        
        # Register offsets (relative) - with module prefix
        # For wide signals (>32 bits), generate _REG0, _REG1, etc. offsets
        for reg in module['registers']:
            reg_name_upper = reg['signal_name'].upper()
            offset_int = reg.get('relative_address_int', reg['address_int'])
            signal_width = self._get_signal_width(reg['signal_type'])
            num_regs = self._get_num_regs(signal_width)
            description = reg.get('description', '')
            
            if num_regs == 1:
                # Single 32-bit register
                offset = reg.get('relative_address', reg['address'])
                if description:
                    lines.append(f"#define {module_prefix}{reg_name_upper}_OFFSET    {offset}  /* {description} */")
                else:
                    lines.append(f"#define {module_prefix}{reg_name_upper}_OFFSET    {offset}")
            else:
                # Multi-register signal
                desc_suffix = f" - {description}" if description else ""
                lines.append(f"/* {reg['signal_name']} is {signal_width} bits wide, occupies {num_regs} registers{desc_suffix} */")
                for i in range(num_regs):
                    reg_offset = offset_int + (i * 4)
                    lines.append(f"#define {module_prefix}{reg_name_upper}_REG{i}_OFFSET    0x{reg_offset:02X}")
        
        lines.extend([
            "",
            "/* Absolute Register Addresses */",
        ])
        
        # Absolute addresses - with module prefix
        for reg in module['registers']:
            reg_name_upper = reg['signal_name'].upper()
            addr_int = reg['address_int']
            signal_width = self._get_signal_width(reg['signal_type'])
            num_regs = self._get_num_regs(signal_width)
            
            if num_regs == 1:
                lines.append(f"#define {module_prefix}{reg_name_upper}_ADDR    {reg['address']}")
            else:
                for i in range(num_regs):
                    reg_addr = addr_int + (i * 4)
                    lines.append(f"#define {module_prefix}{reg_name_upper}_REG{i}_ADDR    0x{reg_addr:X}")
        
        lines.extend([
            "",
            "/* Signal Width Definitions (for multi-register signals) */",
        ])
        
        # Add width definitions for wide signals
        has_wide_signals = False
        for reg in module['registers']:
            signal_width = self._get_signal_width(reg['signal_type'])
            if signal_width > 32:
                has_wide_signals = True
                reg_name_upper = reg['signal_name'].upper()
                num_regs = self._get_num_regs(signal_width)
                lines.append(f"#define {module_prefix}{reg_name_upper}_WIDTH    {signal_width}")
                lines.append(f"#define {module_prefix}{reg_name_upper}_NUM_REGS    {num_regs}")
        
        if not has_wide_signals:
            lines.append("/* No signals wider than 32 bits */")
        
        lines.extend([
            "",
            "/* Register Access Macros (using module base address) */",
            "/* Helper macros for bit field access */",
            "#ifndef GET_FIELD",
            "#define GET_FIELD(val, mask, shift)    (((val) & (mask)) >> (shift))",
            "#endif",
            "",
            "#ifndef SET_FIELD",
            "#define SET_FIELD(val, mask, shift, new_val)    (((val) & ~(mask)) | (((new_val) << (shift)) & (mask)))",
            "#endif",
        ])
        
        # Read macros - with module prefix
        for reg in module['registers']:
            if reg['access_mode'] in ['RO', 'RW']:
                reg_name_upper = reg['signal_name'].upper()
                signal_width = self._get_signal_width(reg['signal_type'])
                num_regs = self._get_num_regs(signal_width)
                
                if num_regs == 1:
                    lines.append(
                        f"#define {module_prefix}READ_{reg_name_upper}()    "
                        f"(*((volatile uint32_t*)({module_name}_BASE_ADDR + {module_prefix}{reg_name_upper}_OFFSET)))"
                    )
                else:
                    # Multi-register read macros
                    for i in range(num_regs):
                        lines.append(
                            f"#define {module_prefix}READ_{reg_name_upper}_REG{i}()    "
                            f"(*((volatile uint32_t*)({module_name}_BASE_ADDR + {module_prefix}{reg_name_upper}_REG{i}_OFFSET)))"
                        )
        
        lines.append("")
        
        # Write macros - with module prefix
        for reg in module['registers']:
            if reg['access_mode'] in ['WO', 'RW']:
                reg_name_upper = reg['signal_name'].upper()
                signal_width = self._get_signal_width(reg['signal_type'])
                num_regs = self._get_num_regs(signal_width)
                
                if num_regs == 1:
                    lines.append(
                        f"#define {module_prefix}WRITE_{reg_name_upper}(val)    "
                        f"(*((volatile uint32_t*)({module_name}_BASE_ADDR + {module_prefix}{reg_name_upper}_OFFSET)) = (val))"
                    )
                else:
                    # Multi-register write macros
                    for i in range(num_regs):
                        lines.append(
                            f"#define {module_prefix}WRITE_{reg_name_upper}_REG{i}(val)    "
                            f"(*((volatile uint32_t*)({module_name}_BASE_ADDR + {module_prefix}{reg_name_upper}_REG{i}_OFFSET)) = (val))"
                        )
                        
        lines.extend([
            "",
            "/* Bit Field Masks and Shifts (for packed registers) */",
        ])
        
        for reg in module['registers']:
            if reg.get('is_packed'):
                # Generate MASK and SHIFT for fields in this packed register
                reg_name_upper = reg['reg_name'].upper() # The container register
                
                for field in reg.get('fields', []):
                    field_name_upper = field['name'].upper()
                    bit_offset = int(field.get('bit_low', 0))
                    width = int(field.get('width', 1))
                    mask = ((1 << width) - 1) << bit_offset
                    
                    lines.append(f"#define {module_prefix}{reg_name_upper}_{field_name_upper}_MASK    0x{mask:X}")
                    lines.append(f"#define {module_prefix}{reg_name_upper}_{field_name_upper}_SHIFT   {bit_offset}")

        lines.extend([
            "",
            "/* Register Default Values */",
        ])
        
        # We need to construct the full 32-bit default for packed registers
        # For standalone, it's easy.
        
        # First, calculate defaults for packed registers
        packed_defaults = {}
        for reg in module['registers']:
            if reg.get('is_packed'):
                reg_name = reg['reg_name']
                if reg_name not in packed_defaults:
                    packed_defaults[reg_name] = 0
                
                default_val = reg.get('default_value', '0')
                bit_offset = int(reg.get('bit_offset', 0))
                
                # Check if default is hex or dec
                # Check if default is hex or dec
                try:
                    if isinstance(default_val, int):
                        val = default_val
                    else:
                        val = int(default_val, 0) # Auto-detect base
                except (ValueError, TypeError):
                    val = 0
                    
                packed_defaults[reg_name] |= (val << bit_offset)

        # Iterate again to generate macros (skipping duplicates for packed)
        processed_packed_defaults = set()
        
        for reg in module['registers']:
            if reg.get('is_packed'):
                reg_name = reg['reg_name']
                if reg_name in processed_packed_defaults:
                    continue
                processed_packed_defaults.add(reg_name)
                
                val = packed_defaults.get(reg_name, 0)
                reg_name_upper = reg_name.upper()
                lines.append(f"#define {module_prefix}{reg_name_upper}_DEFAULT    0x{val:08X}")
                
            else:
                # Standalone
                reg_name_upper = reg['signal_name'].upper()
                default_val = reg.get('default_value', '0')
                try:
                    if isinstance(default_val, int):
                        val = default_val
                    else:
                        val = int(default_val, 0)
                except (ValueError, TypeError):
                    val = 0
                
                # Handling wide signals? Default usually 0 for them in this simple generator for now
                if self._get_signal_width(reg['signal_type']) <= 32:
                     lines.append(f"#define {module_prefix}{reg_name_upper}_DEFAULT    0x{val:08X}")
        
        lines.extend([
            "",
            "/* Register Structure */",
            f"typedef struct {{",
        ])
        
        for reg in module['registers']:
            offset = reg.get('relative_address', reg['address'])
            signal_width = self._get_signal_width(reg['signal_type'])
            num_regs = self._get_num_regs(signal_width)
            description = reg.get('description', '')
            desc_suffix = f" - {description}" if description else ""
            
            if num_regs == 1:
                lines.append(f"    volatile uint32_t {reg['signal_name']};  /* {offset} - {reg['access_mode']}{desc_suffix} */")
            else:
                # Multi-register fields
                for i in range(num_regs):
                    reg_offset_int = reg.get('relative_address_int', reg['address_int']) + (i * 4)
                    lines.append(f"    volatile uint32_t {reg['signal_name']}_reg{i};  /* 0x{reg_offset_int:02X} - {reg['access_mode']} ({signal_width}-bit signal, part {i}){desc_suffix} */")
        
        lines.extend([
            f"}} {module['name']}_regs_t;",
            "",
            "/* Access register block as structure */",
            f"#define {module_name}_REGS    ((volatile {module['name']}_regs_t*)({module_name}_BASE_ADDR))",
            "",
            f"#endif /* {module_name}_REGS_H */",
            ""
        ])
        
        return lines


class XMLGenerator:
    """Generator for creating XML register maps."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        
    def generate_xml(self, module: Dict) -> str:
        """Generate XML register map."""
        module_name = module['name']
        output_filename = f"{module_name}_regs.xml"
        output_path = os.path.join(self.output_dir, output_filename)
        
        lines = self._generate_xml_content(module)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
            
        return output_path
    
    def _generate_xml_content(self, module: Dict) -> List[str]:
        """Generate XML content with round-trip compatible attributes."""
        base_addr = module.get('base_address', 0x00)
        cdc_en = module.get('cdc_enabled', False)
        cdc_stage = module.get('cdc_stages', 2)
        
        lines = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<spirit:component xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5">',
            f'    <spirit:vendor>axion</spirit:vendor>',
            f'    <spirit:library>user</spirit:library>',
            f'    <spirit:name>{module["name"]}</spirit:name>',
            f'    <spirit:version>1.0</spirit:version>',
        ]
        
        # Add CDC configuration as vendor extension for round-trip
        if cdc_en:
            lines.extend([
                '    <spirit:vendorExtensions>',
                f'        <axion:config cdc_en="true" cdc_stage="{cdc_stage}" xmlns:axion="http://axion-hdl.org/extensions"/>',
                '    </spirit:vendorExtensions>',
            ])
        
        lines.extend([
            '    <spirit:memoryMaps>',
            '        <spirit:memoryMap>',
            '            <spirit:name>register_map</spirit:name>',
            '            <spirit:addressBlock>',
            '                <spirit:name>registers</spirit:name>',
            f'                <spirit:baseAddress>0x{base_addr:X}</spirit:baseAddress>',
        ])
        
        # Calculate range (using relative addresses)
        if module['registers']:
            max_offset = max(
                reg.get('relative_address_int', reg['address_int']) 
                for reg in module['registers']
            )
            lines.append(f'                <spirit:range>{max_offset + 4}</spirit:range>')
        else:
            lines.append('                <spirit:range>0</spirit:range>')
            
        lines.append('                <spirit:width>32</spirit:width>')
        
        # Registers
        for reg in module['registers']:
            offset = reg.get('relative_address', reg['address'])
            description = reg.get('description', '')
            r_strobe = reg.get('read_strobe', reg.get('r_strobe', False))
            w_strobe = reg.get('write_strobe', reg.get('w_strobe', False))
            
            # Build strobe attributes string for round-trip compatibility
            strobe_attrs = ''
            if r_strobe:
                strobe_attrs += ' r_strobe="true"'
            if w_strobe:
                strobe_attrs += ' w_strobe="true"'
            
            lines.extend([
                f'                <spirit:register{strobe_attrs}>',
                f'                    <spirit:name>{reg["signal_name"]}</spirit:name>',
            ])
            if description:
                lines.append(f'                    <spirit:description>{description}</spirit:description>')
            lines.extend([
                f'                    <spirit:addressOffset>{offset}</spirit:addressOffset>',
                '                    <spirit:size>32</spirit:size>',
                f'                    <spirit:access>{self._get_xml_access(reg["access_mode"])}</spirit:access>',
                '                    <spirit:field>',
                f'                        <spirit:name>{reg["signal_name"]}_data</spirit:name>',
                '                        <spirit:bitOffset>0</spirit:bitOffset>',
                '                        <spirit:bitWidth>32</spirit:bitWidth>',
                '                    </spirit:field>',
                '                </spirit:register>',
            ])
        
        lines.extend([
            '            </spirit:addressBlock>',
            '        </spirit:memoryMap>',
            '    </spirit:memoryMaps>',
            '</spirit:component>',
            ''
        ])
        
        return lines
    
    def _get_xml_access(self, access_mode: str) -> str:
        """Convert access mode to XML format."""
        mapping = {
            'RO': 'read-only',
            'WO': 'write-only',
            'RW': 'read-write'
        }
        return mapping.get(access_mode, 'read-write')


class YAMLGenerator:
    """Generator for creating YAML register maps."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        
    def generate_yaml(self, module: Dict) -> str:
        """Generate YAML register map."""
        try:
            import yaml
        except ImportError:
            print("  Error: PyYAML required for YAML generation. Install with: pip install PyYAML")
            return ""
            
        module_name = module['name']
        output_filename = f"{module_name}_regs.yaml"
        output_path = os.path.join(self.output_dir, output_filename)
        
        data = self._generate_yaml_data(module)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            yaml.dump(data, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
            
        return output_path
    
    def _generate_yaml_data(self, module: Dict) -> Dict:
        """Generate YAML data structure for round-trip compatibility."""
        base_addr = module.get('base_address', 0x00)
        cdc_en = module.get('cdc_enabled', False)
        cdc_stage = module.get('cdc_stages', 2)
        
        data = {
            'module': module['name'],
            'base_addr': f"0x{base_addr:04X}",
            'config': {
                'cdc_en': cdc_en,
                'cdc_stage': cdc_stage
            },
            'registers': []
        }
        
        for reg in module['registers']:
            offset = reg.get('relative_address_int', reg['address_int'])
            r_strobe = reg.get('read_strobe', reg.get('r_strobe', False))
            w_strobe = reg.get('write_strobe', reg.get('w_strobe', False))
            default_val = reg.get('default_value', 0)
            
            reg_entry = {
                'name': reg['signal_name'],
                'addr': f"0x{offset:02X}",
                'access': reg['access_mode'],
                'width': reg.get('width', 32)
            }
            
            if r_strobe:
                reg_entry['r_strobe'] = True
            if w_strobe:
                reg_entry['w_strobe'] = True
            if reg.get('description'):
                reg_entry['description'] = reg['description']
            if default_val != 0:
                reg_entry['default'] = f"0x{default_val:X}"
            
            # Handle packed registers
            if reg.get('is_packed'):
                reg_entry['fields'] = []
                for field in reg.get('fields', []):
                    field_entry = {
                        'name': field['name'],
                        'bit_offset': field['bit_low'],
                        'width': field['width'],
                        'access': field['access_mode']
                    }
                    if field.get('default_value', 0) != 0:
                        field_entry['default'] = f"0x{field['default_value']:X}"
                    reg_entry['fields'].append(field_entry)
            
            data['registers'].append(reg_entry)
        
        return data


class JSONGenerator:
    """Generator for creating JSON register maps."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        
    def generate_json(self, module: Dict) -> str:
        """Generate JSON register map."""
        import json
        
        module_name = module['name']
        output_filename = f"{module_name}_regs.json"
        output_path = os.path.join(self.output_dir, output_filename)
        
        data = self._generate_json_data(module)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
            
        return output_path
    
    def _generate_json_data(self, module: Dict) -> Dict:
        """Generate JSON data structure for round-trip compatibility."""
        base_addr = module.get('base_address', 0x00)
        cdc_en = module.get('cdc_enabled', False)
        cdc_stage = module.get('cdc_stages', 2)
        
        data = {
            'module': module['name'],
            'base_addr': f"0x{base_addr:04X}",
            'config': {
                'cdc_en': cdc_en,
                'cdc_stage': cdc_stage
            },
            'registers': []
        }
        
        for reg in module['registers']:
            offset = reg.get('relative_address_int', reg['address_int'])
            r_strobe = reg.get('read_strobe', reg.get('r_strobe', False))
            w_strobe = reg.get('write_strobe', reg.get('w_strobe', False))
            default_val = reg.get('default_value', 0)
            
            reg_entry = {
                'name': reg['signal_name'],
                'addr': f"0x{offset:02X}",
                'access': reg['access_mode'],
                'width': reg.get('width', 32)
            }
            
            if r_strobe:
                reg_entry['r_strobe'] = True
            if w_strobe:
                reg_entry['w_strobe'] = True
            if reg.get('description'):
                reg_entry['description'] = reg['description']
            if default_val != 0:
                reg_entry['default'] = f"0x{default_val:X}"
            
            # Handle packed registers
            if reg.get('is_packed'):
                reg_entry['fields'] = []
                for field in reg.get('fields', []):
                    field_entry = {
                        'name': field['name'],
                        'bit_offset': field['bit_low'],
                        'width': field['width'],
                        'access': field['access_mode']
                    }
                    if field.get('default_value', 0) != 0:
                        field_entry['default'] = f"0x{field['default_value']:X}"
                    reg_entry['fields'].append(field_entry)
            
            data['registers'].append(reg_entry)
        
        return data
